//use std::str::FromStr;

use crate::compose_parameters;

use crate::ast::Query;
use crate::ast::Expression;
use crate::ast::Feature;
use crate::ast::Connective;
use crate::ast::Parameter;
use crate::ast::Property;
use crate::ast::StringOperator;
use crate::ast::RelationalOperator;

grammar;

// Lexer
match {
    r"\s*" => { },                                              // ignore whitespace
    r"/\*([^*]|[\r\n]|(\*+([^*/]|[\r\n])))*\*+/|(//.*)" => { }, // comments: /**/ and //

    // all keywords
    "commits"     => commits,
    "deletions"   => deletions,
    "additions"   => additions,
    "changes"     => changes,
    "path"        => path,
    "elapsedTime" => elapsed_time,

    // symbols
    ","  => comma,
    "."  => dot,
    "("  => open_paren,
    ")"  => close_paren,
    "==" => eq,
    "!=" => ne,
    "<"  => lt,
    "<=" => le,
    ">"  => gt,
    ">=" => ge,
    "&&" => and,

    // literals
    r"[-]?[0-9]+"               => INT,
    r#""([^\\"]|\\[~ntr\\])*""# => STRING,
}

pub QUERY: Query = {
    <expression: EXPRESSION> => Query::simple(expression),
}

EXPRESSION: Expression = {
    <head: FEATURE> <tail: (CONNECTIVE_AND_FEATURE)*> => Expression::new(head, tail),
}

CONNECTIVE_AND_FEATURE: (Connective, Feature) = {
    <connective: CONNECTIVE> <feature: FEATURE> => (connective, feature),
}

FEATURE: Feature = {
    commits (open_paren close_paren)? <property: (dot COMMITS_PROPERTY)?> => {
        Feature::Commits { parameters: Vec::new(), property: property.map(|e| e.1) }
    },

    commits open_paren <head: COMMITS_PARAMETER> <tail: (comma COMMITS_PARAMETER)*> comma? close_paren
            <property: (dot COMMITS_PROPERTY)?> => {
        Feature::Commits { parameters: compose_parameters!(head, tail), property: property.map(|e| e.1)}
    },

    additions (open_paren close_paren)? <property: (dot ADDITIONS_PROPERTY)?> => {
        Feature::Additions { parameters: Vec::new(), property: property.map(|e| e.1) }
    },

    additions open_paren <head: ADDITIONS_PARAMETER> <tail: (comma ADDITIONS_PARAMETER)*> comma? close_paren
            <property: (dot ADDITIONS_PROPERTY)?> => {
        Feature::Additions { parameters: compose_parameters!(head, tail), property: property.map(|e| e.1)}
    },

    deletions (open_paren close_paren)? <property: (dot DELETIONS_PROPERTY)?> => {
        Feature::Deletions { parameters: Vec::new(), property: property.map(|e| e.1) }
    },

    deletions open_paren <head: DELETIONS_PARAMETER> <tail: (comma DELETIONS_PARAMETER)*> comma? close_paren
            <property: (dot DELETIONS_PROPERTY)?> => {
        Feature::Deletions { parameters: compose_parameters!(head, tail), property: property.map(|e| e.1)}
    },

    changes (open_paren close_paren)? <property: (dot CHANGES_PROPERTY)?> => {
        Feature::Changes { parameters: Vec::new(), property: property.map(|e| e.1) }
    },

    changes open_paren <head: CHANGES_PARAMETER> <tail: (comma CHANGES_PARAMETER)*> comma? close_paren
            <property: (dot CHANGES_PROPERTY)?> => {
        Feature::Changes { parameters: compose_parameters!(head, tail), property: property.map(|e| e.1)}
    },
}

COMMITS_PARAMETER: Parameter = {
    path <operator: STRING_OPERATOR> <pattern: PATTERN> => Parameter::Path { operator, pattern },
}

ADDITIONS_PARAMETER: Parameter = {
    path <operator: STRING_OPERATOR> <pattern: PATTERN> => Parameter::Path { operator, pattern },
}

DELETIONS_PARAMETER: Parameter = {
    path <operator: STRING_OPERATOR> <pattern: PATTERN> => Parameter::Path { operator, pattern },
}

CHANGES_PARAMETER: Parameter = {
    path <operator: STRING_OPERATOR> <pattern: PATTERN> => Parameter::Path { operator, pattern },
}

COMMITS_PROPERTY: Property = {
    elapsed_time (open_paren close_paren)? => Property::ElapsedTime,
}

ADDITIONS_PROPERTY: Property = {
    elapsed_time (open_paren close_paren)? => Property::ElapsedTime,
}

DELETIONS_PROPERTY: Property = {
    elapsed_time (open_paren close_paren)? => Property::ElapsedTime,
}

CHANGES_PROPERTY: Property = {
    elapsed_time (open_paren close_paren)? => Property::ElapsedTime,
}

CONNECTIVE: Connective = {
    and => Connective::Conjunction,
}

//NUMBER: i32 = {
//    INTEGER => i32::from_str(<>).unwrap(),
//}

PATTERN: String = {
    <s: STRING> => s[1..s.len()-1].to_string(),
}

STRING_OPERATOR: StringOperator = {
    eq    =>  StringOperator::Equal,
    ne    =>  StringOperator::Different,
}

RELATIONAL_OPERATOR: RelationalOperator = {
    eq    =>  RelationalOperator::Equal,
    ne    =>  RelationalOperator::Different,
    lt    =>  RelationalOperator::Less,
    le    =>  RelationalOperator::LessEqual,
    gt    =>  RelationalOperator::Greater,
    ge    =>  RelationalOperator::GreaterEqual,
}


